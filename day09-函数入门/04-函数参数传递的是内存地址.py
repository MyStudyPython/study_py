"""
在python中为我们提供了一个函数`id()`来查看值的内存地址(以十进制展示)

函数在传递参数时，默认不会重新创建一份数据，
在赋值给函数中的参数，而是同时指向同一块内存。

参数传递是：
引用、内存地址




Python参数的这一特性有两个好处：

-   节省内存
-   对于可变类型且函数中修改元素的内容，所有的地方都会修改。可变类型：列表、字典、集合


1. 函数参数的默认值 
Python在创建函数(未执行)时，如果发现函数的参数中有默认值，则在函数内部会创建一块区域并赋值这个默认值
当执行函数向默认值区域传值的时候，则让b指向新传入的值的地址

2. 动态参数的补充
在定义函数时可以用 `*和**`，其实在执行函数时，也可以用
-   形参固定，实参用`*和**`
"""


def demo(b):
    # print(id(b))  # 140530256566448
    pass


a = 123
# print(id(a))  # 140530256566448
demo(a)


def func(a1):
    a1.upper()
    # print(id(a1)) # 1878614870064
    # print(id(a1.upper())) # 1878615344112


v1 = "hhh"
func(v1)

# print(id(v1)) # 1878614870064
# print(v1) # hhh


"""
注意：
a1,v1是同一块内存地址，但由于字符串是不可变类型
a1.upper() 生成新的值 但是没有返回
"""


def func(a1):
    a1.append(666)


v1 = [11, 22, 33]
func(v1)

# print(v1)  # [11, 22, 33, 666]

"""
注意：
a1,v1是同一块内存地址，但由于列表是可变类型
a1.append() 在原列表中追加数据。
"""

"""
- 函数传递参数时，默认传递是内存地址/引用（不会重新拷贝一份数据再传递）
- 一定要注意参数传递时可变/不可变类型：函数内部执行操作时，是重新生成数据；修改原数据

其他很多编程语言执行函数时，默认传参时会将数据重新拷贝一份，会浪费内存

提示注意：其他语言也可以通过 ref 等关键字来实现传递内存地址

当然，如果你不想让外部的变量和函数内部参数的变量一致，也可以选择将外部值拷贝一份，再传给函数
"""

import copy


# 可变类型 & 修改内部修改
def func(data):
    data.append(999)


v1 = [11, 22, 33]
new_v1 = copy.deepcopy(v1)  # 拷贝一份数据，把拷贝的数据传入参数
func(new_v1)
# print(v1)  # [11,22,33]

"""
TIPS:python的内存驻留机制
"""


def demo1():
    demo = [1, 2, 3]
    return demo
    # 函数的每次调用结束，都会销毁内部所有的值
    # 所以


res1 = demo1()
res2 = demo1()
# 由于demo1被调用了两次，所以生成了两次demo并将其进行返回赋值
## 两次都各不相同
print(id(res1))  # 2053770228864
print(id(res2))  # 2053770135424


# 但是也有例外
def demo2():
    demo = "123"
    return demo


res3 = demo2()
res4 = demo2()
# 由于python有着变量驻留机制优化内存，对于所有都不可变数据类型可能会存在指向同一内存地址
print(id(res3))  # 2053770266288
print(id(res4))  # 2053770266288

# 变量驻留机制演示
a = "123456"
b = "123456"
print(id(a))  # 2053770266672
print(id(b))  # 2053770266672

"""
1. 函数参数的默认值 
Python在创建函数(未执行)时，如果发现函数的参数中有默认值，则在函数内部会创建一块区域并赋值这个默认值
当执行函数向默认值区域传值的时候，则让b指向新传入的值的地址
"""


def func(a, b=1):
    # print(a,b)
    pass


# 当执行函数但是并未向默认值区域传值的时候，则让b指向函数维护的那个值的地址
func(1)  # 1 1
# 当执行函数向默认值区域传值的时候，则让b指向新传入的值的地址
func(1, 2)  # 1 2

"""
注意：默认参数如果可变会踩坑
【默认参数的值是可变类型 list/dict/set】 & 【函数内部会修改这个值】
"""

"""
案例一：
"""


def func(a1, a2=[1, 2]):
    a2.append(666)
    print(id(a2))
    print(a1, a2)


"""函数讲解
func函数在定义的时候即会生成a2=[1,2]的内存空间，此函数空间在整个程序运行阶段都存活
假设传入没有传入a2的值，即指向默认值，a2.append即加载默认的空间中
假设有传入值，则将a2指向传入值的空间
"""

func(100)  # 140315508122624 100 [1, 2, 666]
"""
func(100)没有传入a2值，则a2.append则添加默认生成的140315508122624空间a2=[1,2]中
a2使用的内存空间id是140315508122624
"""

func(200)  # 140315508122624 200 [1, 2, 666, 666]
"""
func(200)没有传入a2值，则a2.append则添加默认生成的140315508122624空间a2=[1,2,666]中
a2使用的内存空间id是140315508122624
"""

func(99, [77, 88])  # 140315508124864 99 [77, 88, 666]

"""
func(99,[77,88])传入了a2值，则原本的140315508122624空间被[77,88]的140315508124864空间覆盖，则a2.append则添加到a2=[77,88]中
a2使用的内存空间id是140315508124864
"""

func(300)  # 140315508122624 300 [1, 2, 666, 666, 666]
"""
func(300)没有传入a2值，则a2.append则添加默认生成的140315508122624空间a2=[1,2,666,666]中
a2使用的内存空间id是140315508122624
"""


"""
案例二：
"""


def func(a1, a2=[1, 2]):
    a2.append(a1)
    return a2


v1 = func(10)  # [1, 2, 10, 20, 40]
v2 = func(20)  # [1, 2, 10, 20, 40]
v3 = func(30, [11, 22])  # [11, 22, 30]
v4 = func(40)  # [1, 2, 10, 20, 40]

"""
函数讲解：
1.在函数func定义的时候会生成一块内存空间存放默认参数a2=[1,2]
2.v1 = func(10)执行，由于a2没有传入值，a2即使用默认空间a2=[1,2]，append结果默认空间a2=[1,2,10]，返回值为return a2即v1指向a2默认空间内存地址
3.v2 = func(20)执行，由于a2没有传入值，a2即使用默认空间a2=[1,2,10]，append结果默认空间a2=[1,2,10,20]，返回值为return a2即v2指向a2默认空间内存地址
4.v3 = func(30, [11, 22])指向，a2没有使用默认空间，创建了新空间a2=[11, 22]，append结果新空间a2=[11, 22, 30]，返回值return a2即v3指向a2新空间内存地址
5.v4 = func(40)执行，由于a2没有传入值，a2即使用默认空间a2=[1,2,10,20]，append结果默认空间a2=[1,2,10,20,40]，返回值为return a2即v4指向a2默认空间内存地址


6.此刻 v1.v2.v4都指向最初生成都默认空间，而默认空间都值是[1, 2, 10, 20, 40]，v3指向新空间，新空间对应都值是[11, 22, 30]
"""

"""
2. 动态参数的补充

在定义函数时可以用 `*和**`，其实在执行函数时，也可以用
-   形参固定，实参用`*和**`
-   形参用`*和**`，实参也用 `*和**`
"""

"2.1 形参固定，实参用`*和**"


def func(a1, a2):
    print(a1, a2)


func(11, 22)
func(a1=1, a2=2)

func(*[11, 22])  # 相当于打散，按顺序赋值，把11交给a1,22交给a2
func(**{"a1": 11, "a2": 22})  # 相当于打散，按关键字赋值，把11交给a1,22交给a2

"2. 形参用`*和**`，实参也用 `*和**"


def func(*args, **kwargs):
    print(args, kwargs)


# 注意，这里会把他们都当作顺序传参
## args = ([11,22,33],{"k1":1,"k2":2}) kwargs = {}
func([11, 22, 33], {"k1": 1, "k2": 2})

# 这里在实参中使用*和**
## args=(11,22,33),kwargs={"k1":1,"k2":2}
func(*[11, 22, 33], **{"k1": 1, "k2": 2})

# 值得注意：按照这个方式将数据传递给args和kwargs时，数据是会重新拷贝一份的（可理解为内部循环每个元素并设置到args和kwargs中）

"在format字符串格式化也支持这样的用法"
v1 = "我是{},年龄：{}".format("kinght", 18)
v2 = "我是{name},年龄：{age}".format(name="kinght", age=18)

v3 = "我是{},年龄：{}".format(*["kinght", 18])
v4 = "我是{name},年龄：{age}".format(**{"name": "kinght", "age": 18})
